# 1.Goroutine和线程的区别了解吗

首先，线程它是操作系统层面管的东西，虽然线程比进程轻量，

共享进程的内存空间，但开销其实不小。而且系统能支持的线程数量很有限，

一般开几百上千个就到顶了，再多的话系统调度压力会特别大，性能直接下来。

而 Go 里的 goroutine，我觉得它就是基于线程的 **用户级轻量级线程** ，

是 Go 语言原生支持的。它不是操作系统直接管理的，而是由 Go 自己的运行时来调度。

为什么我们不用纯线程搞并发呢？核心就是线程的调度和创建成本太高了。

而协程切换的时候也不用走内核态，全程在用户态就能完成，

开销特别小。所以我们能轻松开出几万、几十万个 goroutine 来处理并发任务，

这在纯线程的场景下是完全做不到的。

# 2.什么是channel了解吗

channel 是 Go 语言为了适配原生的 goroutine 专门设计的核心数据结构，

channel 必须通过 `make` 初始化才能用，。

比如无缓冲 channel 声明是 `ch := make(chan int)`，

有缓冲的就是 `make(chan int, 5)`，

没初始化的空 channel 读写都会永久阻塞，。

* **无缓冲 channel** ：就像我理解的，它没有数据暂存的空间，发送方把数据发进去之后，会立刻阻塞在这，必须等接收方把数据取走，发送方才能继续执行；反过来接收方如果先去取数据，也会阻塞，直到有发送方把数据发过来。相当于 “一手交数据，一手接数据”，天然是同步的。
* **有缓冲 channel** ：初始化时指定了容量（比如 5），就像有个 “临时仓库”—— 发送方发数据时，只要缓冲区没满，就可以直接把数据存进去，不用阻塞；只有缓冲区满了，发送方才会等。而接收方只要缓冲区里有数据，就能直接取，缓冲区空了才会阻塞。简单说就是能先存数据，等消费端后续来取。

# 3.CSP并发模型了解吗

CSP 是一个并发模型，核心思想就是 

“以通信的方式共享内存”，传递消息的载体也就是 channel。

而 Go 它的并发机制核心就是 goroutine 加 channel。

goroutine 是 Go 里的轻量级用户态线程，创建和切换开销极低，

能轻松开成千上万的实例来实现并发；

channel 则是 goroutine 之间的通信管道，

因此goroutine 之间不用直接共享内存，而是靠 channel 通信来完成数据交互。

# 4.GMP并发模型了解吗

首先说 G，它就是 Goroutine，也就是我们常说的协程

然后是 M，代表 Machine，对应操作系统的内核线程，

是真正执行代码的，所有的 G 最终都要挂载到 M 上才能被 CPU 执行。

最后是 P，它是 Goroutine（G）和操作系统线程（M）之间的 “中间层”，

负责将线程和协程如何分配。

# 5.sync.Mutex互斥锁正常模式和饥饿模式了解吗

正常模式：所有等锁的Goroutine在一个协程锁结束之后需要抢锁，

类似拼手速抢票的场景，但是新来的Goroutine因为在CPU上运行，

不用切换上下文，所以可能老Goroutine一直抢不过，

出现饿死的情况。但这种方式可以减少上下文切换的时间消耗，效率高

饥饿模式：为了防止老Goroutine饿死，

新来的Goroutine进来排队，

Goroutine解锁后会给等待最久的协程抢到锁，

这种方式由于会上下文切换带来的时间消耗，效率低。但是公平。

# 6.sync.Mutex读写锁允许自旋的条件了解吗

1. 锁已被占用，并且锁不处于饥饿模式（这样才会抢锁）。
2. 积累的自旋次数小于最大自旋次数（active_spin=4）。
3. CPU 核数大于 1。
4. 有空闲的 P。。

# 7.sync.RWMutex实现了解吗

会存在一个readerCount计数，

读锁先加锁2个，这个计数就是2，

然后写锁进来想要加锁要先占位，

计数会变成一个很大的负数-max-2代表有两个读锁以及一个占位的写锁，

然后其他读锁或者写锁要加锁是不允许的，

等到读锁都解锁了，计数变成-max，代表只剩一个占位的写锁了，

这个时候写锁拿到锁上锁，解锁后会把计数+max恢复为0。

# 8.sync.WaitGroup了解吗

WaitGroup就是同步等待对象，比如我们要开一组协程，

我们就要在main协程中用wg.add()函数设置子协程的个数，

然后开多个子协程并发执行，

每一个子协程执行开始的时候要defer 一个wg.Done()函数表示该协程结束，

然后main中的等待函数会一直阻塞等待，直到所有任务完成，阻塞释放。


具体来说的话，他维护了两个计数器，

一个是任务计数器，一个是等待计数器。

比如我们要开3个协程，add函数里面写3，

任务计数器的值变成3，然后等待计数器变成1，

代表着有一个协程在等待（也就是main协程在等待），

只要有一个协程执行Done，任务计数器就会减一，

当任务计数器为0，代表协程都结束，等待计数器置0，阻塞解除。

# 9.sync.Pool了解吗

sync.Pool是为了解决回收机制与重新分配的问题，

如果一个高频回收和重新分配的内存的场景发生，

会给GC带来很大负担，于是sync.Pool就会把这些要回收的内存缓存起来，

等到下次用就不用重新分配了。

# 10.Context了解吗

context就是贯穿整个父协程和子协程的信号控制器，

他可以通过外层控制cancel函数来影响子协程内部停止操作，

本质上他是一个channel配合select方式实现的协程是否结束的信号控制。

父协程可以通过控制cancel（）函数来关闭ctx.Done(),然后他的所有子协程都停止了。

# 11.GMP调度流程了解吗

当我们开启一个协程G之后，这个G就加入到P队列进行排队等待，

如果这个P已经满了，就会转到全局队列等待，

每个P队列绑定一个M线程进行处理里面的协程G，

当处理完这个P队列里面的G之后，会去全局批量拿G放到这个P队列执行，

当全局也没G了，就会触发working stealing进行窃取。

当某个G与他的M发生系统调用，会产生阻塞，

这个时候P队列会立刻与当前M解绑，去空闲M队列找休眠M并唤醒，

当系统调用阻塞结束，他的M会回到M队列或者全局队列进行休眠，

这个G也会重新回到P队列等待。

# 12.Golang内存逃逸现象是什么？

**内存逃逸**是指本应在**栈**上分配的局部变量，

如被外部引用，而被编译器**转移到堆**上分配的现象。

1. 函数返回**局部变量的指针**
2. 局部变量被**闭包函数引用**
3. 变量大小 **编译时无法确定** （如大对象(切片)、接口动态分发）
4. 变量在函数内部被存入**全局或包级变量**

# 13.三色标记法原理以及问题

在三色标记法之前的go版本使用的是遍历可达对象的形式实现标记，

进行回收，但是过程要进行STW暂停保护，这样就会影响并发性能。


三色标记法出现后，取消了STW机制，

他会有三个区域：白色区域，灰色区域，黑色区域。

然后程序将所有对象放入白色区域，

然后从栈区开始从根对象遍历可达对象先标记为灰色放入灰色区域中，

接着遍历黑色区域的对象看看他们的可达对象是谁，

并将其放入灰色区域，自己则进入黑色区域，

以此类推最后就会将所有可达对象都放进黑色区域，

剩下的白色对象进行垃圾回收。但是这个问题在于，

由于全程没有STW保护，有可能造成一个黑色对象指向白色对象，

同时指向这个白色对象的灰色对象取消了指向，

结果造成这个对象没有放入黑色区域被当做垃圾回收了。

# 14.强弱三色不变式

强三色不变式是禁止一个黑色对象引用白色对象，


弱三色不变式是允许一个黑色对象引用一个白色对象，

但是这个白色对象必须在他的上游有其他灰色对象直接或者间接引用。

这样就破坏了三色标记法的那个问题发生的条件。

# 15.插入写屏障与删除写屏障

1.插入写屏障（堆上启用）：满足强三色不变式，

当一个黑色对象指向一个白色对象，这个白色对象会被变成灰色对象。

然后栈上的对象会重新触发一轮三色标记，并启动STW保护。

缺点就是为了保护对象，STW还是存在。

2.删除写屏障：被删除的对象如果本身是灰色或者白色，

那么会被标记为灰色，满足弱三色不变式。

所以这个灰色结点会被保护活过这一轮，等到下一轮GC再被清除。

这也是他的一个回收精度低的问题。

# 16.三色标记法——混合写屏障机制

![1766229802584](image/golang八股文/1766229802584.png)
