# Golang底层语法

### 1.使⽤for range 的时候，它的地址会发⽣变化吗？

在Go1.22之前，对于 循环中的迭代变量，其内存地址是不会发⽣变化的。但
是，Go1.22之后的地址是临时的，是变化的，不⼀样的，不再是共享内存了

### 2.如何高效的拼接字符串

1."+"
使⽤ 操作符进⾏拼接时，会对字符串进⾏遍历，

计算并开辟⼀个新的空间来存储原来的两个字符串。

2.fmt.Sprintf
由于采⽤了接⼝参数，必须要⽤反射获取值，因此有性能损耗。

3.strings.Builder：
这是一个结构体，他底层是有一个切片，

然后把各个字符串以byte的方式拼在切片里面，

然后调用它里面的string()方法进行返回，

它是直接把[]byte转换为string，从⽽避免变量重复拷⻉。

（因为对比普通的+拼接长度不变的string类型，+是每次开辟一个

新的空间进行遍历拷贝各个字符串里面的字符拼接，如果多次拼接，

他会反复的拷贝，消耗资源）

4.bytes.Buffer

bytes.Buffer是⼀个缓冲类型的缓冲器，这个缓冲器⾥存放着都是byte ，
bytes.Buffer底层也是⼀个 切⽚。字符串拼接的机制和builder一样。但是他

可以支持其他的功能。

5.strings.join

strings.join也是基于builder来实现的,并且可以⾃定义分隔符，在join⽅法
内调⽤了b.Grow(n)⽅法，这个是进⾏初步的容量分配，⽽前⾯计算的n的⻓度就是我们要拼
接的slice的⻓度，因为我们传⼊切⽚⻓度固定，所以提前进⾏容量分配可以减少内存分配，
很⾼效。

性能⽐较：
strings.Join ≈ strings.Builder > bytes.Buffer > "+" > fmt.Sprintf

### 3.什么是rune类型

rune 类型，代表⼀个 UTF-8 字符，当需要处理中⽂、⽇⽂或者其他复合字符时，则需要
⽤到 rune 类型。假如：

func main(){

var str="hello你好"

fmt.Println("len(str):",len(str))  //普通的len处理字符串的长度这里会输出12，

一个汉字是3个长度

fmt.Println("rune:",len([]rune(str)))  //这里就会输出8

}

### 4.Go 语⾔ tag 有什么⽤？

结构体标签（struct tags）是 Go 中的一种**映射**机制，

用于为结构体字段提供附加的元数据，常见用途包括：

1. **`json`** ：指定字段在 JSON 序列化/反序列化时的名称。
2. **`db`** ：用于数据库框架（如 `sqlx`）中，指定字段与数据库表列的映射关系。
3. **`form`** ：在 Web 框架（如 `Gin`）中，用于映射前端提交的表单字段名。
4. **`binding`** ：与 `form` 标签配合使用，指定字段是否为必填项，若未找到数据则返回错误。

type User struct {
    Name     string `json:"name" db:"username" form:"username" binding:"required"`
    Age      int    `json:"age" db:"age" form:"age"`
    Password string `json:"password" db:"password" form:"password" binding:"required"`
}
在这个例子中：

json:"name"：当你把 User 结构体转换成 JSON 时，Name 字段会变成 name。

db:"username"：当你将 User 结构体与数据库表进行映射时，

Name 字段会映射到数据库中的 username 列。

form:"username"：当你通过 Gin 接收表单数据时，

Name 字段会从前端请求的 username 字段中填充。

binding:"required"：表示 Name 和 Password 是必填字段，

如果前端没有提供这两个字段的值，则会返回错误。

### 5.go 打印时 %v     %+v     %#v 的区别？

%v 只输出所有的值；
%+v 先输出字段名字，再输出该字段的值；
%#v 先输出结构体名字值，再输出结构体（字段名字+字段的值）；
packagemain

import"fmt"

typestudentstruct{

id：int32

name：string

}

func main(){

a:=&student{id:1,name:"微客⻦窝"}

fmt.Printf("a=%v\n",a)//a=&{1微客⻦窝}

fmt.Printf("a=%+v\n",a)//a=&{id:1name:微客⻦窝}

fmt.Printf("a=%#v\n",a)//a=&main.student{id:1,name:"微客⻦窝"}

}

### 6.Go语⾔中空 struct{} 占⽤空间么？有什么用

可以使⽤ unsafe.Sizeof 计算出⼀个数据类型实例需要占⽤的字节数，空struct{}不占⽤任何
空间。如果想用map实现一个set，就可以让map的键存元素，值存空结构体（因为不占空间），

而map中键又是唯一的，所以可以实现集合。或者在一个协程中想传递信号，可以使用channel

传递空结构体来实现（不占空间资源仅传递信号）

### 7.init()函数是什么时候执行的

在main函数之前执⾏。执⾏顺序：import –> const –> var –>init()–>main()

package config

import "fmt"

// 包级变量
var configValue string

// 使用 init 函数初始化配置信息
func init() {
    configValue = "Config initialized!"
    fmt.Println("Config initialized in init function")
}

// 提供一个方法来访问 configValue
func GetConfig() string {
    return configValue
}

package main

import (
    "fmt"
    "yourapp/config"  // 引入 config 包
)

func main() {
    // config 包的初始化已经自动完成，main 中直接使用它
    fmt.Println(config.GetConfig())  // 输出: Config initialized!
}

### 8.两个interface可以==或者！=比较吗？

可以，只要两个接口实例的类型和值都相同就==成立返回True，否则返回False。

### 9.两个nil可能不相等吗？

**`interface{}` 的 `nil` 是包含类型的 `nil`** ：当一个 `interface{}` 被赋值为 `nil` 时，它的  **类型和值都为 `nil`** 。但是如果你将一个指针（比如 `*int` 类型的指针）赋给 `interface{}`，这个指针可能是 `nil`，但是它  **仍然有一个类型** （比如 `*int` 类型）。因此， **`interface{}` 中的 `nil` 和指针类型的 `nil` 是不一样的** 。

### 10.Go 语⾔函数传参是值类型还是引⽤类型

在 Go 语⾔中只存在值传递，要么是值的副本，要么是指针的副本。⽆论是值类型的变量
还是引⽤类型的变量亦或是指针类型的变量作为参数传递都会发⽣值拷⻉，开辟新的内
存空间。

### 11.Go语言的多返回值如何实现

当你调用一个有多个返回值的函数时，Go 会 **提前** 为这些返回值  **在栈上预留空间** 。

当 `return` 执行时，函数会将每个返回值存储到这些预留的位置。

函数返回后，调用方直接从栈帧中  **读取这些返回值** ，而不需要重新分配内存。

### 12.Go语⾔中"_"的作⽤

1. 忽略多返回值：在 Go 语⾔中，函数可以返回多个值。如果你只关⼼其中的⼀部分返回
   值，⽽不需要使⽤其余的，就可以⽤_来忽略它们，从⽽避免编译器报错
2. 当你导⼊⼀个包时，通常会使⽤它的某个功能。但有时你可能只想执⾏包的
   init()函数（例如初始化全局变量），⽽不需要直接使⽤包中的任何导出成员。
   这时，你就可以使⽤_来进⾏匿名导⼊。

### 13.Go语⾔普通指针和unsafe.Pointer有什么区别？

普通指针⽐如 int、string ，它们有明确的类型信息，编译器会进⾏类型检查和垃圾

回收跟踪。不同类型的指针之间不能直接转换，这是Go类型安全的体现。

⽽unsafe.Pointer是Go的通⽤指针类型,它绕过了Go的类型系统。

unsafe.Pointer可以与任意类型的指针相互转换，但是仍然会被GC跟踪回收

### 14.slice是怎么扩容的

slice 扩容是 append 超过 cap 触发，

Go 会新分配更大的底层数组并拷贝。

容量增长上，小 cap（<256）基本翻倍，大 cap 会逐渐变成大概 1.25 倍增长

*当原slice容量(oldcap)⼩于256的时候，*

*新slice(newcap)容量为原来的2倍；原slice容量超过256，*

*新slice容量newcap = oldcap+(oldcap+3*256)/4*

### 15.Map是什么，底层原理是什么

`map` 是基于  **哈希表（Hash Table）实现的键值对数据结构** ，

通过哈希函数把 Key 映射到桶（bucket）中，

然后通过遍历、存储和扩容机制来实现高效的插入、查找和删除操作。

Go 的 `map[Key]Value` 是一种  **无序的键值对集合** 。

map 底层的基本数据结构是hmap 和 bmap，

**hmap** ：map 的主要内部结构体，

保存了所有与 map 相关的状态（桶数量、元素计数、指向桶数组的指针等）。

**bmap（bucket）** ：存储键值对，每个桶能存放多个键值对。

### 16.Map的查找插入过程

首先对 Key 调用哈希函数，得到一个哈希值。

然后哈希值经过掩码计算确定落在哪个桶。

在桶中查找或插入 key-value。

如果桶已满，会延伸到 **溢出桶（旧版本），或使用Swiss Table（新版本）** 。

### 17.处理Map冲突

每个桶最多 8 个位置，如果冲突超过 8 个，就用 **溢出桶** 链接（旧版本做法）。

改进为使用 **Swiss Table**（新版本）

### 18.Map扩容机制

当负载过大（元素数量 vs 桶数量比达到一定阈值），

Go 会触发渐进式扩容，分阶段把旧桶的数据搬到新的更大桶空间里。

### 19.Map并发安全性

Go 的 `map`  **不是线程安全的** 。

并发读写会崩溃（panic），需要使用 `sync.Mutex` 或 `sync.Map` 来保护。

`sync.Map` 是 Go 标准库提供的  **并发安全的 Map** ，可以在多个 goroutine 中安全读写。

它也解决了普通 `map` 在并发读写时会 panic 的问题（Go 的内置 map 不是线程安全的）。

传统做法是用 `map + sync.Mutex/sync.RWMutex` 来保护并发访问，

但这样的大锁会导致大量 goroutine 竞争这个锁，尤其是 **读操作非常多** 时性能不理想。

 `sync.Map` 用read和dirty两个map结构来保存数据，在读操作的时候通过原子性实现无锁读，

写操作会进行加锁。

**`read`（只读 map）**

主要用来快速读取数据。

它是一个 **只读视图（read-only）** ，不会随着每次写操作被修改。

如果要从这里查到 key，就可以**完全无锁**读取，非常快。

`dirty`（脏数据 map）

用来存放 **新加入或被修改但还没有同步到 `read` 的数据** 。

写操作会进入这个区。需要 **加锁** 来保证并发安全。

另外还有一个计数器 `misses`，

统计从 read 找不到 key 而访问 dirty 的次数。

类似redis和mysql的读写分离。

### 20.New、Make的区别

`new` 分配零值内存，返回 `*T`，适用于任意类型；

`make` 只用于 `map/slice/chan`，会初始化内部结构，

返回的是类型本身，所以这三种一般用 make，

否则就是 nil，像 nil map 写会 panic、nil chan 会阻塞。

# Golang底层机制

### 1.Goroutine和线程的区别了解吗

首先，线程它是操作系统层面管的东西，虽然线程比进程轻量，

共享进程的内存空间，但开销其实不小。而且系统能支持的线程数量很有限，

一般开几百上千个就到顶了，再多的话系统调度压力会特别大，性能直接下来。

而 Go 里的 goroutine，我觉得它就是基于线程的 **用户级轻量级线程** ，

是 Go 语言原生支持的。它不是操作系统直接管理的，而是由 Go 自己的运行时来调度。

为什么我们不用纯线程搞并发呢？核心就是线程的调度和创建成本太高了。

而协程切换的时候也不用走内核态，全程在用户态就能完成，

开销特别小。所以我们能轻松开出几万、几十万个 goroutine 来处理并发任务，

这在纯线程的场景下是完全做不到的。

### 2.什么是channel了解吗

channel 是 Go 语言为了适配原生的 goroutine 专门设计的核心数据结构，

channel 必须通过 `make` 初始化才能用，。

比如无缓冲 channel 声明是 `ch := make(chan int)`，

有缓冲的就是 `make(chan int, 5)`，

没初始化的空 channel 读写都会永久阻塞，。

* **无缓冲 channel** ：就像我理解的，它没有数据暂存的空间，发送方把数据发进去之后，会立刻阻塞在这，必须等接收方把数据取走，发送方才能继续执行；反过来接收方如果先去取数据，也会阻塞，直到有发送方把数据发过来。相当于 “一手交数据，一手接数据”，天然是同步的。
* **有缓冲 channel** ：初始化时指定了容量（比如 5），就像有个 “临时仓库”—— 发送方发数据时，只要缓冲区没满，就可以直接把数据存进去，不用阻塞；只有缓冲区满了，发送方才会等。而接收方只要缓冲区里有数据，就能直接取，缓冲区空了才会阻塞。简单说就是能先存数据，等消费端后续来取。

### 3.CSP并发模型了解吗

CSP 是一个并发模型，核心思想就是

“以通信的方式共享内存”，传递消息的载体也就是 channel。

而 Go 它的并发机制核心就是 goroutine 加 channel。

goroutine 是 Go 里的轻量级用户态线程，创建和切换开销极低，

能轻松开成千上万的实例来实现并发；

channel 则是 goroutine 之间的通信管道，

因此goroutine 之间不用直接共享内存，而是靠 channel 通信来完成数据交互。

### 4.GMP并发模型了解吗

首先说 G，它就是 Goroutine，也就是我们常说的协程

然后是 M，代表 Machine，对应操作系统的内核线程，

是真正执行代码的，所有的 G 最终都要挂载到 M 上才能被 CPU 执行。

最后是 P，它是 Goroutine（G）和操作系统线程（M）之间的 “中间层”，

负责将线程和协程如何分配。

### 5.sync.Mutex互斥锁正常模式和饥饿模式了解吗

正常模式：所有等锁的Goroutine在一个协程锁结束之后需要抢锁，

类似拼手速抢票的场景，但是新来的Goroutine因为在CPU上运行，

不用切换上下文，所以可能老Goroutine一直抢不过，

出现饿死的情况。但这种方式可以减少上下文切换的时间消耗，效率高

饥饿模式：为了防止老Goroutine饿死，

新来的Goroutine进来排队，

Goroutine解锁后会给等待最久的协程抢到锁，

这种方式由于会上下文切换带来的时间消耗，效率低。但是公平。

### 6.sync.Mutex读写锁允许自旋的条件了解吗

1. 锁已被占用，并且锁不处于饥饿模式（这样才会抢锁）。
2. 积累的自旋次数小于最大自旋次数（active_spin=4）。
3. CPU 核数大于 1。
4. 有空闲的 P。。

### 7.sync.RWMutex实现了解吗

会存在一个readerCount计数，

读锁先加锁2个，这个计数就是2，

然后写锁进来想要加锁要先占位，

计数会变成一个很大的负数-max-2代表有两个读锁以及一个占位的写锁，

然后其他读锁或者写锁要加锁是不允许的，

等到读锁都解锁了，计数变成-max，代表只剩一个占位的写锁了，

这个时候写锁拿到锁上锁，解锁后会把计数+max恢复为0。

### 8.sync.WaitGroup了解吗

WaitGroup就是同步等待对象，比如我们要开一组协程，

我们就要在main协程中用wg.add()函数设置子协程的个数，

然后开多个子协程并发执行，

每一个子协程执行开始的时候要defer 一个wg.Done()函数表示该协程结束，

然后main中的等待函数会一直阻塞等待，直到所有任务完成，阻塞释放。

具体来说的话，他维护了两个计数器，

一个是任务计数器，一个是等待计数器。

比如我们要开3个协程，add函数里面写3，

任务计数器的值变成3，然后等待计数器变成1，

代表着有一个协程在等待（也就是main协程在等待），

只要有一个协程执行Done，任务计数器就会减一，

当任务计数器为0，代表协程都结束，等待计数器置0，阻塞解除。

### 9.sync.Pool了解吗

sync.Pool是为了解决回收机制与重新分配的问题，

如果一个高频回收和重新分配的内存的场景发生，

会给GC带来很大负担，于是sync.Pool就会把这些要回收的内存缓存起来，

等到下次用就不用重新分配了。

### 10.Context了解吗

context就是贯穿整个父协程和子协程的信号控制器，

他可以通过外层控制cancel函数来影响子协程内部停止操作，

本质上他是一个channel配合select方式实现的协程是否结束的信号控制。

父协程可以通过控制cancel（）函数来关闭ctx.Done(),然后他的所有子协程都停止了。

### 11.GMP调度流程了解吗

当我们开启一个协程G之后，这个G就加入到P队列进行排队等待，

如果这个P已经满了，就会转到全局队列等待，

每个P队列绑定一个M线程进行处理里面的协程G，

当处理完这个P队列里面的G之后，会去全局批量拿G放到这个P队列执行，

当全局也没G了，就会触发working stealing进行窃取。

当某个G与他的M发生系统调用，会产生阻塞，

这个时候P队列会立刻与当前M解绑，去空闲M队列找休眠M并唤醒，

当系统调用阻塞结束，他的M会回到M队列或者全局队列进行休眠，

这个G也会重新回到P队列等待。

### 12.Golang内存逃逸现象是什么？

**内存逃逸**是指本应在**栈**上分配的局部变量，

如被外部引用，而被编译器**转移到堆**上分配的现象。

1. 函数返回**局部变量的指针**
2. 局部变量被**闭包函数引用**
3. 变量大小 **编译时无法确定** （如大对象(切片)、接口动态分发）
4. 变量在函数内部被存入**全局或包级变量**

### 13.如何知道⼀个对象是分配在栈上还是堆上？

 Go局部变量会进⾏逃逸分析。如果变量离开作⽤域后没有被引⽤，则优先
分配到栈上，否则分配到堆上。

### 14.三色标记法原理以及问题

在三色标记法之前的go版本使用的是遍历可达对象的形式实现标记，

进行回收，但是过程要进行STW暂停保护，这样就会影响并发性能。

三色标记法出现后，取消了STW机制，

他会有三个区域：白色区域，灰色区域，黑色区域。

然后程序将所有对象放入白色区域，

然后从栈区开始从根对象遍历可达对象先标记为灰色放入灰色区域中，

接着遍历黑色区域的对象看看他们的可达对象是谁，

并将其放入灰色区域，自己则进入黑色区域，

以此类推最后就会将所有可达对象都放进黑色区域，

剩下的白色对象进行垃圾回收。但是这个问题在于，

由于全程没有STW保护，有可能造成一个黑色对象指向白色对象，

同时指向这个白色对象的灰色对象取消了指向，

结果造成这个对象没有放入黑色区域被当做垃圾回收了。

### 15.强弱三色不变式

强三色不变式是禁止一个黑色对象引用白色对象，

弱三色不变式是允许一个黑色对象引用一个白色对象，

但是这个白色对象必须在他的上游有其他灰色对象直接或者间接引用。

这样就破坏了三色标记法的那个问题发生的条件。

### 16.插入写屏障与删除写屏障

1.插入写屏障（堆上启用）：满足强三色不变式，

当一个黑色对象指向一个白色对象，这个白色对象会被变成灰色对象。

然后栈上的对象会重新触发一轮三色标记，并启动STW保护。

缺点就是为了保护对象，STW还是存在。

2.删除写屏障：被删除的对象如果本身是灰色或者白色，

那么会被标记为灰色，满足弱三色不变式。

所以这个灰色结点会被保护活过这一轮，等到下一轮GC再被清除。

这也是他的一个回收精度低的问题。

### 17.三色标记法——混合写屏障机制

![1766229802584](image/golang八股文/1766229802584.png)
