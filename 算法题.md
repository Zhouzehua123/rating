# 11.岛屿数量

defdfs(grid,visited,x,y,direction):

    for i,j in direction:

    nextx=x+i

    nexty=y+j

    if nextx<0or nexty<0or nextx>=len(grid) or nexty>=len(grid[0]):

    continue

    ifnot visited[nextx][nexty] and grid[nextx][nexty]=="1":

    visited[nextx][nexty]=True

    dfs(grid,visited,nextx,nexty,direction)

classSolution:

    defnumIslands(self, grid: List[List[str]]) -> int:

    direction=[[0,1],[1,0],[-1,0],[0,-1]]

    n=len(grid)

    m=len(grid[0])

    visited=[[False]*m for _ inrange(n)]

    result=0

    for i inrange(n):

    for j inrange(m):

    if grid[i][j]=="1"andnot visited[i][j]:

    result+=1

    visited[i][j]=True

    dfs(grid,visited,i,j,direction)

    return result

# 12.打家劫舍

classSolution:

    defrob(self, nums: List[int]) -> int:

    iflen(nums)==1:

    return nums[0]

    dp=[0]*len(nums)

    dp[0]=nums[0]

    dp[1]=max(nums[0],nums[1])

    for i inrange(2,len(nums)):

    dp[i]=max(nums[i]+dp[i-2],dp[i-1])

    return dp[-1]

# 13.多数元素

classSolution:

    defmajorityElement(self, nums: List[int]) -> int:

    hashmap={}

    maxnum=len(nums)//2

    for i inrange(len(nums)):

    if nums[i] in hashmap:

    hashmap[nums[i]]+=1

    else:

    hashmap[nums[i]]=1

    for key in hashmap:

    if hashmap[key]>maxnum:

    return key

# 14.除自身以外数组的乘积

classSolution:

    defproductExceptSelf(self, nums: List[int]) -> List[int]:

    dp1=[1]*len(nums)

    dp2=[1]*len(nums)

    dp1[1]=nums[0]

    dp2[-2]=nums[-1]

    result=[]

    for i inrange(2,len(nums)):

    dp1[i]=dp1[i-1]*nums[i-1]

    for i inrange(len(nums)-3,-1,-1):

    dp2[i]=dp2[i+1]*nums[i+1]

    for i inrange(len(nums)):

    result.append(dp1[i]*dp2[i])

    return result

# 15.最小栈

classMinStack:

    def__init__(self):

    self.stack=[]

    defpush(self, val: int) -> None:

    self.stack.append(val)

    defpop(self) -> None:

    ifself.stack:

    self.stack.pop()

    deftop(self) -> int:

    ifself.stack:

    returnself.stack[-1]

    else:

    return0

    defgetMin(self) -> int:

    ifself.stack:

    returnmin(self.stack)

    else:

    return0

# 16.最大乘积子数组


classSolution:

    def max Product(self, nums: List[int]) -> int:

    dpmax=[1]*len(nums)

    dpmin=[1]*len(nums)

    dpmax[0]=nums[0]

    dpmin[0]=nums[0]

    for i inrange(1,len(nums)):

    if nums[i]>=0:

    dpmax[i]=max(dpmax[i-1]*nums[i],nums[i])

    dpmin[i]=min(dpmin[i-1]*nums[i],nums[i])

    else:

    dpmax[i]=max(dpmin[i-1]*nums[i],nums[i])

    dpmin[i]=min(dpmax[i-1]*nums[i],nums[i])

    returnmax(dpmax+dpmin)

# 17.排序链表

Definition for singly-linked list.

class ListNode:

    def__init__(self, val=0, next=None):

    self.val = val

    self.next = next

classSolution:

    defsortList(self, head: Optional[ListNode]) -> Optional[ListNode]:

    if not head:

    returnNone

    cur=head

    nodelist=[]

    while cur:

    nodelist.append(cur.val)

    cur=cur.next

    nodelist.sort()

    head=ListNode(val=nodelist[0])

    cur=head

    for i inrange(1,len(nodelist)):

    cur.next=ListNode(val=nodelist[i])

    cur=cur.next

    return head

# 18.LRU缓存


from collections import deque

classLRUCache:

    def__init__(self, capacity: int):

    self.hashmap={}

    self.capacity=capacity

    defget(self, key: int) -> int:

    if key inself.hashmap:

    value=self.hashmap[key]

    self.hashmap.pop(key)#先删除

    self.hashmap[key]=value#再插入字典最后面表示最近使用

    return value

    else:

    return -1

    defput(self, key: int, value: int) -> None:

    if key inself.hashmap:

    self.hashmap.pop(key)

    self.hashmap[key]=value

    else:

    iflen(self.hashmap)==self.capacity:

    self.hashmap.pop(next(iter(self.hashmap)))

    self.hashmap[key]=value

    else:

    self.hashmap[key]=value

# 19.环形链表II


classSolution:

    defdetectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:

    slow, fast = head, head

    whileTrue:

    ifnot fast ornot fast.next:

    returnNone

    slow = slow.next

    fast = fast.next.next

    if slow == fast:

    break

    #与环形链表不一样的地方是这个，需要额外再找一次

    fast = head

    while slow != fast:

    fast = fast.next

    slow = slow.next

    return slow


# 20.环形链表


classSolution:

    defhasCycle(self, head: Optional[ListNode]) -> bool:

    slow, fast = head, head

    whileTrue:

    ifnot fast ornot fast.next:

    returnFalse

    slow = slow.next

    fast = fast.next.next

    if slow == fast:

    return True
